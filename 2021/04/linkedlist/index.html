<!DOCTYPE html>
<html lang="en-us">

<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="Description" content="All about technology.">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
         Linked List &middot; DSA
    </title>
    
    <!-- CSS -->
    <link rel="stylesheet" href="../../../css/poole.css">
    <link rel="stylesheet" href="../../../css/syntax.css">
    <link rel="stylesheet" href="../../../css/hyde.css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Text" rel="stylesheet">
    <link rel="stylesheet" href="/path/to/styles/default.css">
    <script src="/path/to/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  
    <!-- Icons -->
    <link rel="shortcut icon" href="../../../assets/techs.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../assets/techs.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../assets/techs.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../assets/techs.png">
    <!-- <link rel="manifest" href="/assets/site.webmanifest"> -->
    <link rel="mask-icon" href="../../../../assets/safari-pinned-tab.svg" color="#41a9c7">
    <link rel="shortcut icon" href="../../../assets/techs.png">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="msapplication-config" content="../../../assets/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../atom.xml">

    <!-- Javascript -->
    
    <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1DEV7XD3S2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-1DEV7XD3S2');
    </script>    

</head>


<body class="theme-base-purpz">

  <div class="sidebar">
<div class="container sidebar-sticky">

  <div class="sidebar-about">
    <h1>
      <a href="../../../index.html">
        Techs Blog
      </a>
    </h1>
    <!-- <p class="lead">Simple Techs</p> -->
    <p class="lead">@arch-techs</p>

  </div>


    <nav class="sidebar-nav">
      <a class="sidebar-nav-item " href="../../../../index.html">Home</a>

      

      
      
        
        
          
        
      
        
        
          
          
        
      
        
            
        
        
          
          
        
      
        
        
          
            <a class="sidebar-nav-item " href="../../../../about/index.html">About</a>
          
        
      
        
        
          
        
      
        
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
      
        
        
          
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      

      <div class="sidebar-nav-item">
    
        <div class="sidebar-nav-item">
          <p>
              <a href="https://github.com/hoangndst" target="_blank">
              Github <i class="fa fa-github" aria-hidden="true"></i></a>
              &nbsp;
              <a href="https://www.linkedin.com/in/nguyendinhhoang252/" target="_blank">
                  LinkedIn <i class="fa fa-linkedin-square"></i>
              </a>&nbsp;
              <a href="https://www.instagram.com/hoangndst" target="_blank">Instagram
                  <i class="fa fa-instagram" aria-hidden="true"></i></a>
          </p>
      </div>
    </nav>

    <p>&copy All rights reserved.</p>
  </div>
</div>

<!-- Mailchimp -->
<script type="text/javascript" src="https://downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script>

<script type="text/javascript">
function showMailingPopUp() {
    console.log("showing popup");
    window.dojoRequire(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us8.list-manage.com","uuid":"31c71a4d79bd53ab3c537a59e","lid":"2416515c90","uniqueMethods":true}) })
    document.cookie = "MCPopupClosed=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
};

document.getElementById("open-popup").onclick = function() {showMailingPopUp()};
</script>


    <div class="content container">
      <div class="post">
  <h1 align="center" class="post-title">Linked List</h1>
  
<div>
      <!-- Snippet to calculate reading time assuming WPM 200 -->
<span style="display: inline" class="post-date" title="Estimated read time">
    08.04.2021 &middot; @arch-techs
</span>
  </div>
  <br>
<p>Danh sách liên kết là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử không được lưu trữ tại các vị trí bộ nhớ liền kề. Các phần tử trong danh sách được liên kết được liên kết bằng cách sử dụng con trỏ như được hiển thị trong hình ảnh bên dưới:</p>
<center>
  <img src="../../../assets/img/linked-list-diagram.png">
</center>

<p>Bắt đầu với cấu trúc đơn giản nhất</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  struct Node {
    int value; // Value of Node
    Node *next; // Pointer to next Node
  };
</code></pre></div></div>

<p>Trong hàm main ta khai báo như sau:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  Node *one = new Node();
  Node *two = new Node();
  Node *three = new Node();
  // Set one is head
  Node *head = one;
  
  // Set value
  one->value = 1;
  two->value = 2;
  three->value = 3;

  // Link
  one->next = two;
  two->next = three;
  // head -> next -> next
  // one -> two -> three
</code></pre></div></div>
</div>

<p>Như vậy chúng ta đã có một list. Giờ chúng ta muốn thêm một phần tử zero vào một vị trí bất kì thì làm thế nào?</p>
<p>1. Thêm ở đầu</p>

<center>
  <img src="../../../assets/img/Linkedlist_insert_at_start.png">
</center>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>
  void addhead(int value, Node **head) {
    Node *new_head = new Node(); // Create new Node
    new_head->value = value; // set new Node value
    new_head->next = *head; // set next of new Node is head
    *head = new_head; // set head is new Node
  }
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  Node *one = new Node();
  Node *two = new Node();
  Node *three = new Node();
  // Set one is head
  Node *head = one;
  
  // Set value
  one->value = 1;
  two->value = 2;
  three->value = 3;

  // Link
  one->next = two;
  two->next = three;
  // head -> next -> next
  // one -> two -> three

  addhead(0, &head); // set head->value = 0
  cout << head->value; // head->value = 0 
</code></pre></div></div>
<p>Cho những bạn chưa hiểu tại sao trong hàm <code>addhead(0, &head)</code>, <code>&head</code> ở đây có nghĩa chúng ta đang cho vào địa trỉ của một biến con trỏ.</p>
<p>Chúng ta đưa vào địa trỉ để thay đổi giá trị nó, cái này gọi là tham chiếu, còn nếu là <code>Node *head</code> thì chỉ truyền vào giá trị, ta không thay đổi được sau khi kết thúc hàm, đó gọi là tham trị.</p>
<br>
<p>2. Thêm sau một vị trí cho trước</p>
<center>
  <img src="../../../assets/img/Linkedlist_insert_middle.png">
</center>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  void insertAfter(Node *index, int value) {
    if (index == NULL) return; // check index
    Node *new_node = new Node();
    new_node->value = value;
    new_node->next = index->next; 
    // set new_node next is index->next (Link)
    index->next = new_node;
  }

</code></pre></div></div>
<p>Phần này khá dễ hiểu mọi người hãy nhìn hình minh họa nguồn GFG</p>
<br>
<p>3. Thêm vào đuôi</p>
<center>
  <img src="../../../assets/img/Linkedlist_insert_last.png">
</center>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  void append(Node **head, int value) {
    Node *new_end = new Node();
    new_end->value = value; 
    new_end->next = NULL; // have to
    if (*head == NULL) {
      *head = new_end; 
      return;
    }
    // if list is empty set head is new_end and return; to break out
    Node *tmp = *head;
    while(tmp) {
        tmp = tmp->next; // move tmp to the end
    }
    tmp->next = new_end; 
    // add new_end to tmp->next ez right?
  }
</code></pre></div></div>

<p>Tương tự trên thì <code>&head</code> bạn chỉ cần hiểu đơn gian là địa trỉ của một con trỏ trỏ để head</p>
<br>
<p>4. Test</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  void printlist(Node *node) {
    while(node) {
        cout << node->value << " ";
        node = node->next;
    }
  }

int main() {
    
    Node *head = NULL;
    append(&head, 0); // 0
    append(&head, 2); // 0 2
    insertAfter(head, 1); // 0 1 2
    append(&head, 3); // 0 1 2 3
    printlist(head);
    
    return 0;
}

</code></pre></div></div>
<p>Test thử tại máy bạn để xem kết quả!</p>
<br>
<p>5. Xóa phần tử có giá trị bằng x</p>
<p>Cho một linked list chúng ta hay xóa phần tử có value = x</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  void delete_value(Node **head, int x) {
    Node *tmp = *head;
    Node *prev = NULL;
    if (tmp == NULL) return;
    // break if list == NULL
    if (tmp->value == x) {
      head = tmp->next;
      delete tmp;
      // free tmp
    }
    else {
      while (tmp->value != x) {
        prev = tmp;
        tmp = tmp->next;
      }
      if (tmp == NULL) return;
      prev->next = tmp->next;
      delete tmp;
    }
  }

</code></pre></div></div>
<br>
<p>6. Xóa phần tử tại vị trí cho trước</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  void delete_pos(Node **head, int pos) {
    Node *tmp = *head;
    if (tmp == NULL) return;
    if (pos == 0) {
        *head = tmp->next;
        delete tmp;
        return;
    }
    pos = pos - 1;
    for (int i = 0; i < pos; i++) {
        tmp = tmp->next;
    }
    Node *aft = tmp->next->next;
    delete tmp->next;
    tmp->next = aft;
  }
</code></pre></div></div>
<p>Xem hoạt ảnh sau để có thể dễ dàng hiểu:</p>
<center>
  <img src="../../../assets/img/deleteposvisual.gif">
</center>
<br>
<p>7. Xóa một linked list?</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  void delete_list (Node **head) {
    Node *curr = *head;
    Node *next = NULL;
    while (curr) {
        next = curr->next;
        delete curr;
        curr = next;
    }
    *head = NULL;
  }

</code></pre></div></div>
<br>
<p>8. Tìm độ dài của list</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  int list_len(Node *head) {
    int len = 0;
    Node *tmp = head;
    while (tmp) {
        tmp = tmp->next;
        len++;
    }
    return len;
  }
</code></pre></div></div>
<p>Ở đây chúng ta chỉ cần xét giá trị không cần thiết phài <code>Node **head</code> để truy đến địa trỉ, chúng ta chỉ cần biến đếm và không cần thay đổi giá trị gì cả :D!</p>
<br>
<p>9. Check xem trong list có giá trị nào bằng x không:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  bool search(Node *head, int value) {
    Node *tmp = head;
    while(tmp) {
        if (tmp->value == value) return true;
        tmp = tmp->next;
    }
    return false;
  }
</code></pre></div></div>
<p>Tương tự như trên, ta chả cần thay đổi giá trị hay gì cả nên chỉ cần truyền tham trị.</p>
<br>
<p>10. Lấy giá trị tại vị trí cho trước</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  int getNth(Node *head, int index) {
    Node *tmp = head;
    int len = list_len(head);
    if (index > len) return -1;
    while (index--) {
        tmp = tmp->next;
    }
    return tmp->value;
  }
</code></pre></div></div>
<p>Đầu tiên check xem index có nằm ngoài độ dài không? Nếu thỏa mãn, cho tmp chạy đến vị trí index rồi trả về giá trị tại đó.</p>
<br>
<p>11. Tìm độ dài của loop trong linked list</p>
<center>
  <img src="../../../assets/img/linkedlist-loop-detect.png">
</center>
<p>Đầu tiên hay tìm hiểu cách kiểm tra xem có loop trong linked list hay không?</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  bool loopDetec(Node *head) {
    Node *fast = head;
    Node *slow = head;
    while (fast && slow && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
      if (fast == last) return true;
    }
    return false;
  }
</code></pre></div></div>
<p>Ta cho <code>slow, fast</code> chạy cho đến khi hai con trỏ bằng nhau thì chứng tỏ có loop. Dễ hiểu đúng không?</p>
<p>Còn một cách nữa là sử dụng <code>set</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  bool loopDetec(Node *head) {
    Node *tmp = head;
    set&lt;Node*&gt; set;
    while(tmp) {
        if(set.find(tmp) != set.end()) {
            return true;
        } else {
            set.insert(tmp);
        }
        tmp = tmp-&gt;next;
    }
    return false;
  }
</code></pre></div></div>
<p>Chúng ta đã có cách kiểm tra và biết vị trí loop chính là tại <code>slow || fast</code> tại thời điểm nó bằng nhau. Giờ hay tiếp với hàm tìm độ dài của loop này.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  int countfrom(Node *index) {
    int len = 1;
    Node *tmp = index;
    while (tmp->next != index) {
      len++;
      tmp = tmp->next;
    }
    return len;
  }
</code></pre></div></div>
<p>Hàm trên là hàm đếm độ dài và input là con trỏ tại vị trí có loop, tức là vị trí <code>end->next</code>, đã đi đến đây thì bạn sẽ dễ dàng hiểu được hàm.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  int countLoop(Node *head) {
    Node *slow = head;
    Node *fast = head;
    while (slow && fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
      if (fast == slow) {
        return countfrom(slow);
        // or return countfrom(fast);
      }
    }
    return 0;
  }
</code></pre></div></div>
<p>Dựa vào cách kiểm tra loop thì ta viết hàm <code>countLoop</code>.</p>
<br><br />
<p>12. Xóa phần tử lặp của một List chưa được sắp xếp:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  void removeDuplicates (Node **head) {
    Node *curr = *head;
    Node *prev = NULL;
    unordered_set&lt;int&gt; set;
    while (curr) {
        if (set.find(curr-&gt;value) != set.end()) {
            prev-&gt;next = curr-&gt;next;
            delete curr;
        } else {
            set.insert(curr-&gt;value);
            prev = curr;
        }
        curr = prev-&gt;next;
    }   
  }
</code></pre></div></div>
<p>Ta sẽ sử dụng <code>Hashing</code> để có thể có độ phức tạp là <code>O(n)</code>.</p>
<br><br />
<p>13. Intersection of Two Linked Lists (LeetCode) | Giao điểm của hai danh sách được liên kết.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  Node *getIntersectionNode (Node *headA, Node *headB) {
    set&lt;Node *&gt;set;
    Node *a = headA;
    Node *b = headB;
    while(a) {
        set.insert(a);
        a = a-&gt;next;
    }
    while(b) {
        if (set.find(b) != set.end()) {
            return b;
        } else {
            b = b-&gt;next;
        }
    }
    return NULL;
}
</code></pre></div></div>
<br><br />
<p>14. Reverse Linked Lists (LeetCode) | Đảo ngược dslk.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    Node *reverseList(Node **head) {
        Node *curr = *head;
        Node *prev = NULL;
        while(curr) {
            Node *tmp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = tmp;
        }
        return prev;
    }
</code></pre></div></div>
<ul>
  <li>Time complexity : <code>O(n)</code>. Assume that nn is the list's length, the time complexity is <code>O(n)</code>.</li>
  <li>Space complexity : <code>O(1)</code>.</li>
</ul>
<br><br />
<p>15. Remove Elements (LeetCode):</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    Node *removeElements(Node **head, int value) {
        Node *curr = head;
        Node *prev = new Node();
        prev->next = head; 
        // prev slower than curr 1 step
        while(curr) {
            if(curr->value == value) {
                prev->next = curr->next;
            } else {
                prev = prev->next;
            }
            curr = curr->next;
        }
        return *head;
    }
</code></pre></div></div>
<br> <br />
<p>16. Odd Even Linked List (LeetCode)</p>
<center>
  <img src="../../../assets/img/328_Odd_Even.svg">
  <p>Nguồn: LeetCode</p>
</center>
<p>Ở đây bài toán mặc định phần tử đầu tiên là lẻ, phần tử thứ hai là chẵn, ta sẽ giải quyết theo hướng chia ra làm hai list rồi nối chúng lại với nhau.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  Node *oddevenList(Node **head) {
    Node *odd = *head;
    Node *even = odd->next;
    Node *evenHead = even;
    while(even && even->next) {
        odd->next = even->next;
        odd = odd->next;
        even->next = odd->next;
        even = even->next;
    }
    odd->next = evenHead;
    return *head;
}

</code></pre></div></div>

<p>Còn tiếp...!</p>

<div class="related">
  <h3>Related Posts</h3>
  <ul class="related-posts">

        
    
  </ul>
</div>

    </div>

    <!-- Default Statcounter code for My blog
  http://hoangndst.github.io -->
  <p><small>Total visits: 
    <script type="text/javascript">
    var sc_project=12514193; 
    var sc_invisible=0; 
    var sc_security="220ef100"; 
    var sc_text=5; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="Web Analytics"
    href="https://statcounter.com/" target="_blank"><img
    class="statcounter"
    src="https://c.statcounter.com/12514193/0/220ef100/0/"
    alt="Web Analytics"></a></div></noscript><a href="https://statcounter.com/p12514193/?guest=1"> (Powered
    by Statcounter)</a></small></p>
    <!-- End of Statcounter Code -->


  </body>
  
  <script src="https://use.fontawesome.com/ba4ba69796.js"></script>


</html>