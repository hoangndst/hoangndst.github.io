<!DOCTYPE html>
<html lang="en-us">

<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="Description" content="All about technology.">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
         Kmeans Visualization and Image Compression
    </title>
    
    <!-- CSS -->
    <link rel="stylesheet" href="../../../css/poole.css">
    <link rel="stylesheet" href="../../../css/syntax.css">
    <link rel="stylesheet" href="../../../css/hyde.css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Text" rel="stylesheet">
    <link rel="stylesheet" href="/path/to/styles/default.css">
    <script src="/path/to/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  
    <!-- Icons -->
    <link rel="shortcut icon" href="../../../assets/techs.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../assets/techs.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../assets/techs.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../assets/techs.png">
    <!-- <link rel="manifest" href="/assets/site.webmanifest"> -->
    <link rel="mask-icon" href="../../../../assets/safari-pinned-tab.svg" color="#41a9c7">
    <link rel="shortcut icon" href="../../../assets/techs.png">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="msapplication-config" content="../../../assets/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../atom.xml">

    <!-- Javascript -->
    
    <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1DEV7XD3S2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-1DEV7XD3S2');
    </script>    

</head>


<body class="theme-base-purpz">

  <div class="sidebar">
<div class="container sidebar-sticky">

  <div class="sidebar-about">
    <h1>
      <a href="../../../index.html">
        Techs Blog
      </a>
    </h1>
    <!-- <p class="lead">Simple Techs</p> -->
    <p class="lead">@arch-techs</p>

  </div>


    <nav class="sidebar-nav">
      <a class="sidebar-nav-item " href="../../../../index.html">Home</a>

      

      
      
        
        
          
        
      
        
        
          
          
        
      
        
            
        
        
          
          
        
      
        
        
          
            <a class="sidebar-nav-item " href="../../../../about/index.html">About</a>
          
        
      
        
        
          
        
      
        
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
      
        
        
          
          
        
      
        
        
          
        
      
        
        
          
        
      
        
        
          
        
      

      <div class="sidebar-nav-item">
    
        <div class="sidebar-nav-item">
          <p>
              <a href="https://github.com/hoangndst" target="_blank">
              Github <i class="fa fa-github" aria-hidden="true"></i></a>
              &nbsp;
              <a href="https://www.linkedin.com/in/nguyendinhhoang252/" target="_blank">
                  LinkedIn <i class="fa fa-linkedin-square"></i>
              </a>&nbsp;
              <a href="https://www.instagram.com/hoangndst" target="_blank">Instagram
                  <i class="fa fa-instagram" aria-hidden="true"></i></a>
          </p>
      </div>
    </nav>

    <p>&copy All rights reserved.</p>
  </div>
</div>

<!-- Mailchimp -->
<script type="text/javascript" src="https://downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script>

<script type="text/javascript">
function showMailingPopUp() {
    console.log("showing popup");
    window.dojoRequire(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us8.list-manage.com","uuid":"31c71a4d79bd53ab3c537a59e","lid":"2416515c90","uniqueMethods":true}) })
    document.cookie = "MCPopupClosed=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
};

document.getElementById("open-popup").onclick = function() {showMailingPopUp()};
</script>


    <div class="content container">
      <div class="post">
  <h1 align="center" class="post-title">Kmeans Visualization and Image Compression</h1>
  
<div>
      <!-- Snippet to calculate reading time assuming WPM 200 -->
<span style="display: inline" class="post-date" title="Estimated read time">
    12.2020 &middot; @arch-techs
</span>
  </div>
  <br>
<p>Chương trình được mình viết trên cả hai ngôn ngữ là <code>Python</code> và <code>C++</code> vì khá rảnh :).</p>
<p>Link Source Code cho mọi người có hứng thú tham khảo:</p>
<ul>
    <li><i class="fa fa-github" aria-hidden="true"></i> : <a href="https://github.com/hoangndst/kmeans-visualization-cpp" target="_blank"> Built with C++ and SDL2</a></li>
    <li><i class="fa fa-github" aria-hidden="true"></i> : <a href="https://github.com/hoangndst/kmeans-img-compression" target="_blank"> Built with Python and Pygame</a></li>

</ul>

<br><br />
<p>Tóm tắt nội dung— Bài toán phân cụm có nhiệm vụ phân
    chia một tập hợp các đối tượng (còn gọi là các thành viên) thành
    các nhóm khác nhau (gọi là các cụm) dựa trên các đặc điểm
    của đối tượng. Các thành viên của một nhóm sẽ có nhiều điểm
    tương đồng hơn so với những thành viên trong nhóm khác. Bài
    viết này nói về một phương pháp phân cụm được gọi là thuật
    toán K-Means dưới góc độ toán học và quá trình tạo lên nó từ
    thư viện SDL2 và ngôn ngữ C++, Python và Pygame cũng tương tự chỉ khác về function.</p>

    <br><br />
<p>1. Giới thiệu</p>
<p>Bài toán phân cụm có nhiều ứng dụng khác nhau: khai
    thác dữ liệu học máy và khám phá kiến thức, nén dữ
    liệu, nhận dạng mẫu và phân loại mẫu.
    Mục tiêu của Thuật toán K-Means là phân tách chính
    xác các đối tượng trong tập dữ liệu thành các nhóm dựa trên
    thuộc tính của đối tượng. Ví dụ, các đối tượng có thể là
    ngôi nhà và thuộc tính của chúng là kích thước, số tầng, vị
    trí, mức tiêu thụ điện năng mỗi năm, v.v. Mục đích là phân
    loại tập dữ liệu nhà thành các nhóm giàu, trung bình, nghèo.
    Trong trường hợp đó, tất cả các thuộc tính của các ngôi nhà
    phải được xử lý để chuyển thành số để tạo ra một vector, quá
    trình này được gọi là vectơ hóa.
    Một ví dụ khác, lấy các điểm trong bảng làm đối tượng và
    mỗi đối tượng có hai thuộc tính là vị trí trục x và trục y, với
    đầu vào K = 3.</p>
<center>
    <img src="../../../assets/img/f1 (1).png">
    <p>Hình 1. Các đối tượng chưa được chia nhóm.</p>
    <img src="../../../assets/img/f2 (1).png">
    <p>Hình 2. Các đối sau khi được chia nhóm</p>
</center>
<br><br />
<p>2. Giải thích thuật toán và Source Code</p>

<p>Thuật toán nhận vào một tập hợp:</p>

\[X = \left[x_{1}, x_{2}, ... , x_{n}\right] \in \mathbf{R} ^{d.n}  \]
<br><br />
<p>$d$ là chiều của mỗi vector, $n$ là số vector. Cuối cùng nhận đầu vào  $K$ là số nhóm muốn chia.</p>
<p>Thuật toán sẽ xuất ra K điểm trung tâm $\left[m_{1}, m_{2}, ..., m_{K}\right] \in \mathbf{R} ^{d.K}$  của K nhóm và gắn mác(nhãn, nhóm thuộc về) cho từng điểm đầu vào.</p>
<p>Thuật toán có thể áp dụng cho tập hợp các dữ liệu vector nhiều chiều, vì phần mêm mô phỏng trên mặt phẳng $Oxy$ hai chiều nên bài viết sẽ nói về hai chiều để có một cách tiếp cận dễ nhất, đối với nhiều chiều các bước làm cũng tương tự.</p>
<p>Tập hợp nhận vào là các vector có tọa độ $(x, y)$ là tọa độ của chuột tại vị trí nhấp chuột.</p>
<p>Bước đầu chúng ta cần tạo một mảng, vector hai chiều để lưu trữ các điểm đầu vào, sau đó sẽ nhận vào vị trí của chuột và input vào mảng, vector hai chiều đó.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  vector&lt;vector&lt;double&gt;&gt; points;
  ...
  while(window.isRunning) {
  ...
      
  int mouse_x, mouse_y;
  SDL_GetMouseState(&amp;mouse_x, &amp;mouse_y); 
  ...
  if (event.type == SDL_MOUSEBUTTONDOWN) {
      if ([mouse in points space]) {
          labels.clear();
          vector&lt;double&gt; tmp; 
          int x = mouse_x - 11; // nhan vao toa do x
          int y = mouse_y - 11; // nhan vao toa do y
          tmp.push_back(x); 
          tmp.push_back(y);
          points.push_back(tmp);
          tmp.clear();
      }
  }
}
</code></pre></div></div>
<br><br />
<p>Bước tiếp theo chúng ta sẽ khai báo và nhận đầu vào K, và tạo một mảng, vector hai chiều rồi random ra K điểm có tọa độ $(x, y)$ bất kỳ và nhập nó vào trong mảng, vector hai chiều vừa tạo. </p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  #include &lt;time.h&gt; // ham random
  int K = 0;
  vector&lt;vector&lt;double&gt;&gt; clusters;
  ...
  while(window.isRunning()) {
          ...
          
      if ([mouse in random space]) {
          clusters.clear(); // make sure = []
          labels.clear();
          for (int i = 0; i &lt; K; i++) {
              // random 10 &lt; r1 &lt; 1178 - 10
              // random 10 &lt; r2 &lt; 598 - 10
              int r1 = 10 + rand() % (1178 - 10 + 1 - 10);
              int r2 = 10 + rand() % (598 - 10 + 1 - 10);
              vector&lt;double&gt; rand;
              rand.push_back(r1);
              rand.push_back(r2);
              clusters.push_back(rand);
              rand.clear();
          }
          cerr &lt;&lt; &quot;Random exc&quot; &lt;&lt; endl;
      }
  }
</code></pre></div></div>
<br><br />
<p>Bước tiếp theo là chạy thuật toán. Nói một cách đơn giản chúng ta đang có $points = [p_{1}, p_{2}, ..., p_{n}] \in  \mathbf{R} ^{2.n}$ là tập hợp các điểm ta nhấp lên màn hình. $clusters = [c_{1}, c_{2}, ... , c_{K}] \in \mathbf{R}^{2.K} $ là số  điểm mà chúng ta vừa random. Bây giờ chúng ta sẽ tính khoảng cách của từng điểm trong $points$ tới các điểm trong $clusters$ rồi lưu nó vào một list mới $distancetocl$. \[distancetocl = \left[d_{1}, d_{2}, ..., d_{K}\right] \in \mathbf{R}^{2.K}\]</p>
<p>Sau khi có list $distancetocl$ ta sẽ tìm ra (giá trị nhỏ nhất) khoảng cách nhỏ nhất của điểm đầu (points[0]) đến từng điểm trong $clusters$ ghi nhớ vị trí (index) của nó rồi lưu vào list $labels$. Tiếp tục tính tương tự đối với các phần tử tiếp theo trong list $points$.</p>
  \[labels = [l_{1}, l_{2}, ..., l_{n}] \in \mathbf{R} ^{1.n}\]
<p>Mỗi giá trị trong $labels$ sẽ đánh dấu các điểm K </p>
<p> Múc đích của việc này là đẻ gắn nhãn cho các điểm.</p>
<br><br />
<p>Giờ hãy khai báo mảng và tạo hàm tính khoảng cách:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  double dis(vector&lt;double&gt; vect1, vector&lt;double&gt; vect2) {
    return double(sqrt(pow((vect1[0] - vect2[0]), 2) + pow((vect1[1] - vect2[1]), 2)));
  }
</code></pre></div></div>
<center>
  <p> Hàm tính khoảng cách</p>
</center>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  if ([mouse in run space]) {
    // change points color
    labels.clear();
    for (int i = 0; i &lt; points.size(); i++) {
        vector&lt;double&gt; distance_to_cl;
        for (int j = 0; j &lt; clusters.size(); j++) {
            double tmp1 = dis(points[i], clusters[j]);
            distance_to_cl.push_back(tmp1);
        }
            double min_dis = *min_element(distance_to_cl.begin(), distance_to_cl.end());
            labels.push_back(getIndex(distance_to_cl, min_dis));
    }
    ...
  }
</code></pre></div></div>
<center>
  <p>Chạy thuật toán</p>
</center>
<br><br />
<p>Tiếp theo chúng ta sẽ cập nhật tọa độ của từng điểm K trong $clusters$, cứ tiếp tục vòng lặp cho đến khi phân chia được kết quả</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  ...
  // change clusters pos
 for (int i = 0; i &lt; clusters.size(); i++) {
     double sum_x = 0;
     double sum_y = 0;
     double count = 0;
     for (int j = 0; j &lt; points.size(); j++) {
         if (labels[j] == i) {
             sum_x = sum_x + points[j][0];
             sum_y = sum_y + points[j][1];
             count = count + 1;
         }
     }
     if (count != 0) {
         clusters[i][0] = sum_x/count;
         clusters[i][1] = sum_y/count;
     }
 }
 ...
</code></pre></div></div>

<p>Tọa độ mới của từng điểm K là trung bình cộng của các điểm trong $points$ được gán vào nhóm K đó. Sau khi có vị trí K mới ta sẽ cập nhật lại cho đến khi vị trí của K được cố định</p>

<br>
<a href="https://github.com/hoangndst/kmeans-visualization-cpp/blob/master/report/report.pdf"><code>PDF version</code></a>
<br>



<div class="related">
  <h3>Related Posts</h3>
  <ul class="related-posts">

        

    
  </ul>
</div>

    </div>

  </body>
  
  <script src="https://use.fontawesome.com/ba4ba69796.js"></script>


</html>
